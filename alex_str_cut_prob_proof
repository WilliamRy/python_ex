"""
The problem: Let S be a string whose characters are from [0-9]. By insert some commas,  
S can be splitted into some substrings and each substring can be viewed as a decimal 
integer. Let X(S) be the set of non-decreasing sequence generated by splitting S. Let 
L(S) be the set of longest sequences in X(S). Write a function that return a element in 
L(S) for any input S.
"""
#=======================================================================================
The solution function is based on the following proposition:

Proposition: Let M(S) be the sequences in X(S) who has the smallest last number. Let Y(S) be the
              sequences in M(S) who has the longest length. Then Y(S) is a subset of L(S).
proof of prop:
We prove this prop inductively for n the length of S. Obviously, the prop is true for n = 1.
Suppose the prop is proved for n <= k, then consider n = k+1. Assuming the prop is not true,
then there exist p belongs to Y(S) and q belongs to L(S) such that p[-1] < q[-1] and len(p) < len(q).
From p[-1] < q[-1]  we know that len(p[-1]) < len(q[-1]), hence q+ = q[:-2] + [q[-2]+S[-len(q[-1]):-len(p[-1])]]
belongs to X(S+), where S+ = S[:-len(p[-1])]. Since len(p) < len(q), we have len(p[:-1]) = len(p)-1 < len(q)-1 = len(q+)
Let r be an element of Y(S+), then since len(S+) <= k, by assumption we have r belongs to L(S+). Hence
r[-1] <= p[-2], then p+ = r + [p[-1]] belongs to X(S), and len(p+) = len(r)+1 >= len(q+) +1> len(p[:-1])+1 = len(p).
Now we have p+ belongs to Y(S) but len(P+) > len(p), which contradict to p belongs to Y(S).
Therefore our assumption is false, the prop for n = k+1 is true.


In the solution function, we find an element s_k of Y(S_k) inductively, where S_k = S[:k], k = 1,...,n . 
So in the worst case, at k step we have to consider {s_i}(i<k), then the time complexity of this algorithm is O(n^2).
But generally(S doesn't have a lot of zeros), as a result of some optimizing, we can hope the complexity is O(nlogn). 



#==================================
